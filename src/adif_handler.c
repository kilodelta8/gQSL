#include "../include/adif_handler.h"  // Adjust path if needed
#include "../include/log_manager.h"   // Adjust path if needed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <time.h>    // For generating timestamp

// Define ADIF version gQSL uses
#define ADIF_VERSION "3.1.5"
#define PROGRAM_ID "gQSL"
#define PROGRAM_VERSION "0.1.0" // Update as your app versions

// Helper function to write a single ADIF tag <NAME:LEN>VALUE
static gboolean write_adif_tag(FILE *file, const char *tag_name, const char *tag_value) {
    if (!tag_name || !tag_value || !file) {
        return FALSE;
    }
    // Don't write empty tags (unless ADIF spec requires it for specific fields)
    if (strlen(tag_value) == 0) {
        return TRUE; // Not an error, just skip
    }
    // ADIF length is byte length
    size_t len = strlen(tag_value);
    // Format: <TAG_NAME:LENGTH>VALUE
    int written = fprintf(file, "<%s:%zu>%s ", tag_name, len, tag_value);
    return (written > 0);
}


gboolean adif_export_to_file(const char *filename) {
    if (!filename || filename[0] == '\0') {
        g_warning("ADIF Export Error: Invalid filename provided.");
        return FALSE;
    }

    FILE *outfile = fopen(filename, "w");
    if (!outfile) {
        g_warning("ADIF Export Error: Could not open file '%s' for writing.", filename);
        return FALSE;
    }

    g_print("Starting ADIF export to '%s'...\n", filename);

    // --- Write Header ---
    fprintf(outfile, "ADIF Export generated by %s v%s\n", PROGRAM_ID, PROGRAM_VERSION);
    fprintf(outfile, "<ADIF_VER:%zu>%s ", strlen(ADIF_VERSION), ADIF_VERSION);
    fprintf(outfile, "<PROGRAMID:%zu>%s ", strlen(PROGRAM_ID), PROGRAM_ID);
    fprintf(outfile, "<PROGRAMVERSION:%zu>%s ", strlen(PROGRAM_VERSION), PROGRAM_VERSION);

    // Add timestamp
    GDateTime *now = g_date_time_new_now_utc();
    char *timestamp = g_date_time_format(now, "%Y%m%d %H%M%S");
    if (timestamp) {
        fprintf(outfile, "<CREATED_TIMESTAMP:%zu>%s ", strlen(timestamp), timestamp);
        g_free(timestamp);
    }
    g_date_time_unref(now);

    fprintf(outfile, "<EOH>\n\n"); // End of Header

    // --- Write Records ---
    int count = get_log_entry_count();
    g_print("Exporting %d log entries...\n", count);
    for (int i = 0; i < count; i++) {
        LogEntry *entry = get_log_entry(i);
        if (!entry) continue;

        // Write mandatory/common fields (add more as LogEntry expands)
        write_adif_tag(outfile, "QSO_DATE", entry->qso_date);
        write_adif_tag(outfile, "TIME_ON", entry->time_on);
        write_adif_tag(outfile, "CALL", entry->call);
        // Format frequency (example: 3 decimal places)
        char freq_str[20];
        snprintf(freq_str, sizeof(freq_str), "%.3f", entry->freq);
        write_adif_tag(outfile, "FREQ", freq_str);
        write_adif_tag(outfile, "BAND", entry->band); // Assumes band is stored correctly
        write_adif_tag(outfile, "MODE", entry->mode);
        write_adif_tag(outfile, "RST_SENT", entry->rst_sent);
        write_adif_tag(outfile, "RST_RCVD", entry->rst_rcvd);

        // Write MY_* fields from the entry (which should ideally match preferences)
        write_adif_tag(outfile, "STATION_CALLSIGN", entry->my_call); // Or use OPERATOR
        write_adif_tag(outfile, "MY_CALL", entry->my_call);
        write_adif_tag(outfile, "MY_GRIDSQUARE", entry->gridsquare);

        // TODO: Add writing for other MY_* fields (MY_NAME, MY_LAT, MY_LON, etc.)
        // based on LogEntry struct when those fields are added to it.
        // Example: write_adif_tag(outfile, "MY_RIG", entry->my_rig);


        fprintf(outfile, "<EOR>\n"); // End of Record
    }

    fclose(outfile);
    g_print("ADIF Export finished successfully.\n");
    return TRUE;
}


// Imports logbook entries from the specified ADIF file.
gboolean adif_import_from_file(const char *filename) {
     if (!filename || filename[0] == '\0') {
        g_warning("ADIF Import Error: Invalid filename provided.");
        return FALSE;
    }

    FILE *infile = fopen(filename, "r");
    if (!infile) {
        g_warning("ADIF Import Error: Could not open file '%s' for reading.", filename);
        return FALSE;
    }

     g_print("Starting ADIF import from '%s'...\n", filename);

    // --- ADIF Parsing Logic ---
    // This is a very simplified placeholder and needs significant work
    // A robust parser needs to handle various states, tags, lengths, values, EOR, EOH etc.

    char line_buffer[2048]; // Buffer for reading lines/chunks
    int imported_count = 0;
    int skipped_count = 0;

    // Very basic example: read line by line (ADIF is NOT line based, proper parsing needed!)
    // A real parser would read character by character or use a state machine.
    while (fgets(line_buffer, sizeof(line_buffer), infile)) {
        // TODO: Implement actual ADIF parsing here.
        // - Find '<' to start tag detection.
        // - Extract TAG_NAME.
        // - Find ':' and extract LENGTH.
        // - Find '>' and read LENGTH bytes for VALUE.
        // - Store FIELD=VALUE pairs for the current record.
        // - Detect <EOR> marker.
        // - On <EOR>, create LogEntry from stored pairs and add via add_log_entry().
        // - Clear stored pairs for the next record.
        // - Handle <EOH>.
        // - Handle errors gracefully.

        // --- Placeholder ---
        // This example just looks for a CALL tag anywhere in the line
        char *call_ptr = strstr(line_buffer, "<CALL:");
        if (call_ptr) {
             // Extremely basic value extraction - WILL FAIL on real ADIF!
             char call_val[20] = {0};
             sscanf(call_ptr, "<CALL:%*d>%19[^< ]", call_val); // Very unsafe!

             if (strlen(call_val) > 0) {
                // Create a dummy entry for now
                 LogEntry *entry = create_log_entry("Imported", "Import", call_val, 0.0, "IMP", "", "", "", "", "");
                 if (add_log_entry(entry)) {
                     imported_count++;
                 } else {
                    // List might be full, free the entry
                    free_log_entry(entry);
                    skipped_count++;
                 }
             }
        }
         // --- End Placeholder ---
    }


    fclose(infile);

    if (imported_count > 0) {
         g_print("ADIF Import finished. Imported %d records", imported_count);
         if (skipped_count > 0) {
             g_print(" (skipped %d due to errors or log limit)", skipped_count);
         }
         g_print(".\n");
         // TODO: Need to trigger a UI update for the list view after import!
         // update_log_list_view(); // This function needs to be callable from here, or signal emitted.
         return TRUE; // Indicate success (at least partially)
    } else {
         g_warning("ADIF Import finished, but no valid records were imported (or parser is incomplete).");
         return TRUE; // Still TRUE as file was read, but maybe signal no records added?
    }

}


/* Final newline added below */
